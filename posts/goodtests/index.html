<!doctype html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<meta charset="utf-8">
		
		<link rel="stylesheet" href="https://federico-arias.github.io/sass/main.min.css"/>
<style>

</style>
	</head>
	<body>


		<nav>
			<div class="logo">
				<h1>
					<a href="/">
						{ federico-arias } 
					</a>
				</h1>
			</div>
			<div class="menu">
				<ul>
					<li>
						<a href="/about/">
							About me
						</a>
					</li>
					<li>
						<a href="/hireme/">
							Hire me!
						</a>
					</li>
				</ul>
			</div>
		</nav>

		<div class="container single-post">
			<h1>
				A simpler approach at testing Redux middlewares
			</h1>
			<div class="meta">
				<div class="meta__date">
				</div>
				<div class="meta__author">
					<img src="/logo.jpeg"/>
				</div>
				<div class="meta__tags">
				</div>
			</div>
			<p>One of the hardest parts of testing Redux components is having
to mock the store.  It seems that every project has
its own idiosincratic way of simulating it, leaving
you with the task of understanding how they decided to
implement it. Usually, this means navigating through multiple
util packages to grok how everything was pierced together.</p>

<p>Maybe that&rsquo;s why <a href="https://www.youtube.com/watch?v=oO-FMAdjY68">this talk</a> made so much sense
to me. It basically claims that you should be able to understand
tests without having to read more code than what it is
strictly necesary, even if this means duplicating your code.
That is, favor readability in spite of DRY-ness.</p>

<p>In the spirit of this idea, I tried to simplify the way
I test middlewares and came up with this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">api</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;../middlewares/api&#39;</span>;
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">API_REQUEST</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;../actions/api&#39;</span>;
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">fetchMock</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;fetchMock&#39;</span>;

<span style="color:#a6e22e">it</span>(<span style="color:#e6db74">&#39;should trigger a call to fetch()&#39;</span>, () =&gt; {
	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">store</span> <span style="color:#f92672">=</span> {
		<span style="color:#a6e22e">getState</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">jest</span>.<span style="color:#a6e22e">fn</span>(() =&gt; ({})),
		<span style="color:#a6e22e">dispatch</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">jest</span>.<span style="color:#a6e22e">fn</span>()
	}
	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">jest</span>.<span style="color:#a6e22e">fn</span>();
	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">action</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">API_REQUEST</span>, <span style="color:#a6e22e">meta</span><span style="color:#f92672">:</span> {}};

	<span style="color:#a6e22e">api</span>(<span style="color:#a6e22e">store</span>)(<span style="color:#a6e22e">next</span>)(<span style="color:#a6e22e">action</span>);
	<span style="color:#a6e22e">expect</span>(<span style="color:#a6e22e">fetchMock</span>.<span style="color:#a6e22e">called</span>).<span style="color:#a6e22e">toBeTruthy</span>;
});
</code></pre></div>
<p>Which, as you can see, mocks the whole store in a couple
of lines of code. Here, we are testing that the
<code>API_REQUEST</code> action triggers a call to <code>fetch()</code>.</p>

<p>This code is neither DRY nor it exposes an interface to
enable reusability.  Probably, there are going to be
cases when you are going to need a more complex store,
and you&rsquo;ll end up writing multiple implementations for
each individual case. Writing code on a per-test basis
might seem counter-intuitive
but you&rsquo;ll have to admit the readability of this line of
code is a lot better than any obscure <code>mockStore()</code> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">api</span>(<span style="color:#a6e22e">store</span>)(<span style="color:#a6e22e">next</span>)(<span style="color:#a6e22e">action</span>);
</code></pre></div>
<p>Which is immediately recognizable by anyone that knows
the signature of a Redux middleware function. Writing
tests in this way ensures that whomever is reading
our code is going to immediately understang where
we are going and doesn&rsquo;t need to spend a lot of time
understanding our really smart store implementation.</p>

<p>This might be one of the the better examples for the
old adage &ldquo;clear is better than clever&rdquo;.
Although I love reading clever
code, because there is always something to
learn from it, reading it inside tests (where you
are supposed to understand what clever code is trying to
achieve) always feels like an overkill.</p>

		</div>
	</body>
</html>
